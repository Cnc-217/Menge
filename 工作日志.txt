9.28
1  修改agent 的prefspeed无效？
2  一个思路是在进入服务or阻塞队列时修改maxspeed=0  并在结束服务时改回来  但是并不行？第一次进入以后就不动了
3  在2的基础上  如果改成一个很小的值如0.1  那么整个地图上只有一两个agent在动  远远少于不修改时（30）的agent活跃程度=>maxspeed和仿真时间有关？
4  在1的基础上  如果修改OlympicS文件里的prefpeed是可以实现的  但好像没什么用？

9.29
1  接着前一天的1  修改agent的prefspeed是可以的  修改后cout出来确实是0   但是并不能达到停下来的效果

9.30
1  尝试通过修改maxspeed来使agent停下来  但是agent在goal的停留时间明显受maxspeed的控制？
方式：如果到达  修改case0的maxspeed  服务结束以后在case2把maxspeed修改回去
结果：不修改  1.49s  10  2.16s  1  9.31s  0.1  10min21.19s
=>maxspeed与timestep有关？

10.13
1  更新了basescene的shopinit函数  传参方式改为txt文本形式  函数读取文本信息后写入全局变量shopinfo中  可供后续使用
test.txt文件中为一个10*4的二维矩阵  
行数为goalset的id  即第一行即是goalset id = 1  这与OlympicB.xml文件中goalset的id顺序一致
列数为该goalset的相关信息  从左到右分别为  店铺类型（吃买玩噪点出入口） 店铺数量（几间）  服务队列的容量  阻塞队列的容量
2  将reachagent改为全局变量  放在core中

10.22
1  更新了baseagent内agent的模板  添加了一个shopgone队列  记录曾经到过的五家店
   在conditionwait中进行调用  在出函数的时候判断是否已经达到5  否则会无限地记录下去
2  完成了一个简单版的goalselect函数  命名为getGoalNearlyNew（getGoalNearly为废弃版）
   在函数调用之前判断是否大于1/3  是的话用新的  否则用旧的
   新的首先获取当前店铺的goalset内的店铺ID（如同为滑雪场的goal的ID）此时有0.1的概率会把自己也放进数组内
   此时再在数组内部取随机数  是哪个就去哪个
   以上只针对购买类型的商店和noisepoint（连续地吃玩和进出出入口并不实际）
   
10.28
在socket中更新了一些自动get电脑IP的函数  但是实际调用过程中会有一些问题
例如一个电脑往往不止一个IP  会有无线网IP  还有以太网IP  甚至会有一些虚拟网卡  且不是所有的网卡都是启用的  因此会出现拿到多个IP但是不知道哪个是现有IP的问题